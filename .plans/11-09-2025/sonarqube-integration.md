Check [agents.md](../../agents.md) and [problem.md](../../problem.md) for overall monorepo context.

# SonarQube Integration Plan (POC) - 11/09/2025

## Goal
Integrate SonarQube analysis into the existing PNPM + Vitest monorepo producing a single, aggregated coverage signal (Option A: ONE SonarQube project). This is a disposable proof-of-concept: ephemeral container, embedded H2 (no external DB, no persistent volumes), manual token creation, manual scanner execution.

## Non-Goals (Explicit Exclusions)
* No data persistence (every run resets state).
* No multi-project SonarQube setup (Option B deferred).
* No CI or PR decoration.
* No custom quality gates or portfolio management.

## High-Level Flow
1. Generate coverage with existing Vitest setup (`pnpm test:coverage`).
2. Start ephemeral SonarQube container (Community Edition) using embedded H2.
3. Manually create a user token in SonarQube UI (admin/admin default credentials).
4. Run Node-based Sonar scanner from workspace root, publishing combined coverage and sources.
5. Inspect metrics & coverage in SonarQube UI.
6. (Optional) Re-run including `app-c` sources to observe coverage drop.

## Project Modeling Decision
POC uses a SINGLE SonarQube project representing both `app-a` and `app-b` (excluding `app-c` by default to reflect only tested code). Rationale: reduces operational overhead and highlights coverage aggregation without noise from untested control app.

To include `app-c` later: add its `src` path to `sonar.sources` or remove exclusion entry.

## Required Artifacts (All Manual unless noted)
| Artifact | Purpose | Status |
|----------|---------|--------|
| `sonar-project.properties` | Scanner configuration | To author (below) |
| Ephemeral SonarQube container | Analysis server | Manual run |
| Sonar token | Auth for scanner | Manual creation |
| Coverage file `coverage/lcov.info` | LCOV report from Vitest | Generated by tests |
| Scanner dev dependency | Local CLI invocation | Optional (recommended) |

## Proposed `sonar-project.properties`
Place at repository root (NOT committed yet until validated):
```
sonar.projectKey=vitest-coverage-poc
sonar.projectName=Vitest Coverage Aggregation POC
# SonarQube Integration Plan (POC, Finalized) - 11/09/2025

# Production source roots (exclude control app initially)
sonar.sources=apps/app-a/src,apps/app-b/src
# To include control app uncomment:
# sonar.sources=apps/app-a/src,apps/app-b/src,apps/app-c/src

# Tests definition (keep tests recognized separately)
2. **Start devcontainer** (VS Code will automatically start SonarQube Community Edition as a service using embedded H2; no manual Docker Compose needed).
3. Manually create a user token in SonarQube UI (admin/admin default credentials).
4. Run Node-based Sonar scanner from workspace root, publishing combined coverage and sources.
5. Inspect metrics & coverage in SonarQube UI (http://sonarqube:9000 from within the devcontainer, or forwarded port from host).
6. (Optional) Re-run including `app-c` sources to observe coverage drop.
# Alternative exclusion pattern if you want to keep sources list broad:
# sonar.exclusions=**/*.test.ts,apps/app-c/src/**

# Coverage (Vitest LCOV combined report)
sonar.javascript.lcov.reportPaths=coverage/lcov.info

# Optional shaping (NOT recommended long-term):
# sonar.coverage.exclusions=apps/**/utils.ts

# Version tagging (optional)
# sonar.projectVersion=0.1.0
```

## Docker Compose (Ephemeral SonarQube Developer Edition)
Use this file for a repeatable ephemeral SonarQube Developer Edition instance (embedded H2, no persistence, no volumes). Place at workspace root:

`docker-compose.sonarqube-dev.yml`:
```yaml
version: "3.9"
services:
	sonarqube:
		image: sonarqube:10.8-developer
		container_name: sq-poc-dev
		ports:
			- "9000:9000"
		# No volumes: ephemeral H2 DB, no persistence
		environment:
			# No SONAR_JDBC_* to keep embedded H2
			TZ: UTC
		healthcheck:
			test: ["CMD", "curl", "-sf", "http://localhost:9000/api/system/status"]
			interval: 10s
			timeout: 5s
			retries: 15
```

To start SonarQube Developer Edition:
```bash
docker compose -f docker-compose.sonarqube-dev.yml up -d
```

To stop and remove the container:
## SonarQube as a Devcontainer Service (Community Edition)
SonarQube Community Edition is now defined as a service in `.devcontainer/docker-compose.yml`. **You do not need to run Docker Compose manually.** VS Code will start the service automatically when you open the devcontainer.

Key points:
- Service hostname is `sonarqube` (use `http://sonarqube:9000` for scanner and scripts).
- No data persistence (embedded H2, no volumes).
- Port 9000 is forwarded for host access if configured in devcontainer.
docker compose -f docker-compose.sonarqube-dev.yml down
```
## Scanner Dependency (Node Variant)
Add dev dependency and script at root (recommended inside devcontainer):
```bash
pnpm add -D sonarqube-scanner
```

Create `scripts/sonar-scan.mjs`:
```js
import scanner from 'sonarqube-scanner';

// Expect SONAR_TOKEN and SONAR_HOST_URL env vars.
scanner({
	serverUrl: process.env.SONAR_HOST_URL || 'http://localhost:9000',
	token: process.env.SONAR_TOKEN,
	options: {
		'project.settings': 'sonar-project.properties'
	}
To start SonarQube Community Edition:
```bash
No manual action required. Open the devcontainer in VS Code; SonarQube Community Edition will be started automatically as a service.
```
```

### Workspace Root Package.json (Planned Script Additions)
Do NOT execute yet; this is the proposed modification to the root `package.json` `scripts` section to streamline local and remote analysis workflows.

Add (or extend) the following scripts:
```jsonc
{
	"scripts": {
		// Existing test scripts
		"test": "vitest run",
		"test:coverage": "vitest run --coverage",

		// Preparation: runs coverage before scan (fails fast if lcov missing)
		"sonar:prep": "pnpm test:coverage && test -f coverage/lcov.info",

		// Local SonarQube scan (assumes SONAR_TOKEN & SONAR_HOST_URL exported)
		"sonar:scan": "node scripts/sonar-scan.mjs",

		// Convenience combo: generate coverage + scan in one step
		"sonar:upload": "pnpm sonar:prep && pnpm sonar:scan",

		// Remote server variant (explicit URL override)
		"sonar:upload:remote": "SONAR_HOST_URL=$SONAR_REMOTE_URL pnpm sonar:prep && pnpm sonar:scan"
	}
}
```

Usage patterns:
```bash
# Local ephemeral server already running on localhost:9000
export SONAR_TOKEN=your_token
export SONAR_HOST_URL=http://localhost:9000
pnpm sonar:upload

# Remote server (e.g., staging) – set SONAR_REMOTE_URL first
export SONAR_REMOTE_URL=https://staging-sonar.example.com
export SONAR_TOKEN=your_remote_token
pnpm sonar:upload:remote
```

Environment variables required:
* `SONAR_TOKEN` – user token created manually in target SonarQube instance.
* `SONAR_HOST_URL` – base URL for local scans (defaults inside script if not supplied, but recommend explicit export).
* `SONAR_REMOTE_URL` – only for the remote variant script.

Optional guard improvements (future): replace `test -f coverage/lcov.info` with a small Node script validating file size > 0 bytes.

## Creating `sonar-project.properties` (Step-by-Step Instructions)
1. Confirm you are at workspace root: `pwd` → should end with repository folder.
2. Create file: `touch sonar-project.properties`.
3. Paste the proposed contents (see earlier section) into the file.
4. Decide whether to include `app-c` sources now or later (POC default: exclude).
5. (Optional) Adjust `sonar.projectVersion` if tagging a run (e.g., align with git tag).
6. DO NOT add credentials (tokens) to this file; keep auth via environment variables.
7. Commit only after successful first scan validation.
8. Re-run `pnpm sonar:prep` after any change to ensure coverage file remains valid.

Validation command (dry run coverage existence only):
```bash
grep -q "SF:apps/app-a/src/calculator.ts" coverage/lcov.info && echo "lcov looks OK"
```

Rollback procedure if configuration causes missing source files in Sonar:
1. Remove custom exclusions.
2. Simplify `sonar.sources` to only one app to isolate issue.
3. Re-run scan and compare server UI differences.


Alternatively, run the official CLI via Docker (bypasses local dependency):
```bash
docker run --rm \
	-e SONAR_HOST_URL=http://host.docker.internal:9000 \
	-e SONAR_LOGIN=$SONAR_TOKEN \
	-v "$(pwd)":/usr/src \
	sonarsource/sonar-scanner-cli:latest
```

## Manual Execution Steps
### 1. Generate Coverage
```bash
pnpm test:coverage
test -f coverage/lcov.info
```

### 2. Start SonarQube (choose one)
```bash
docker run --rm -d --name sq-poc -p 9000:9000 sonarqube:10.8-community
# or (compose)
docker compose -f docker-compose.sonarqube.yml up -d
```

### 3. Wait for readiness
Visit http://localhost:9000 OR poll:
```bash
until curl -sf http://localhost:9000/api/system/status | grep -q '"UP"'; do echo 'waiting...'; sleep 5; done
```
### 2. Start SonarQube (choose one)
```bash
docker run --rm -d --name sq-poc -p 9000:9000 sonarqube:10.8-community
# or (compose)
docker compose -f docker-compose.sonarqube.yml up -d
```
### 4. Create Token (Manual UI)
Visit http://sonarqube:9000 from within the devcontainer, or use the forwarded port from your host. You can also poll:
```bash
until curl -sf http://sonarqube:9000/api/system/status | grep -q '"UP"'; do echo 'waiting...'; sleep 5; done
```
export SONAR_TOKEN=YOUR_TOKEN
export SONAR_HOST_URL=http://localhost:9000
pnpm sonar:scan
### 5. Run Scanner (Node variant)
```bash
export SONAR_TOKEN=YOUR_TOKEN
export SONAR_HOST_URL=http://sonarqube:9000
pnpm sonar:scan
```
### 7. Cleanup
```bash
docker stop sq-poc  # Container removed automatically if run with --rm
### 7. Cleanup
No cleanup required; stopping the devcontainer will stop and remove the SonarQube service automatically.
| Step | Command | Expected |
|------|---------|----------|
| Coverage file exists | `ls coverage/lcov.info` | File present |
| SonarQube UP | `curl -sf localhost:9000/api/system/status` | JSON contains `UP` |
| Scanner success | (scan command) | Exit 0, summary printed |
| Coverage imported | UI shows non-zero coverage | ~60% |
| Control app experiment | Add `app-c` to sources + rescan | Coverage % decreases |

## Troubleshooting Quick Wins
| Symptom | Cause | Fix |
|---------|-------|-----|
| 0% coverage | Wrong `reportPaths` or coverage not regenerated | Re-run `pnpm test:coverage` and confirm path |
| Project missing files | `sonar.sources` path mismatch | Check relative paths; use `pwd` for root confirmation |
| Auth failure | Bad token or not exported | Re-export `SONAR_TOKEN` env var |
| Scanner fails to connect | Docker networking isolation | Use `--network=host` (Linux) or adjust host URL |

## Security Considerations (POC)
* Admin credentials left default (acceptable only for local ephemeral usage).
* Token stored in shell env; avoid committing to repo or `.env` without gitignore.
* No persistence means secrets vanish when container stops – reduces cleanup burden.

## Future Enhancements (Next Steps)
1. Separate Sonar projects per app (distinct `sonar.projectKey`s).
2. CI pipeline (GitHub Actions) with cached scanner and quality gate enforcement.
3. Introduce quality gate thresholds (e.g., `coverage > 70%`).
4. Add `app-c` progressively and track coverage improvement as tests are added.
5. Language expansion (e.g., Rust crates with converted coverage → LCOV or native).
6. Security/secret scanning integration (plugins) once persistence added.
7. Automated token generation via REST + jq script (beyond manual UI step).

## Open Decisions To Confirm Later
| Item | Current Default | Revisit When |
|------|-----------------|--------------|
| Include control app | Excluded | After adding tests to app-c |
This plan intentionally mirrors the style of `bootstrap.md` but is now fully adapted for devcontainer-native workflows. Proceed with creating `sonar-project.properties` and `scripts/sonar-scan.mjs` if not already present. All onboarding and troubleshooting is now aligned with VS Code devcontainer service orchestration.
| Scanner method | Node wrapper | In CI (likely official CLI container) |

---
This plan intentionally mirrors the style of `bootstrap.md` focusing on phased clarity and manual operator steps. Proceed with creating `sonar-project.properties` and `scripts/sonar-scan.mjs` once approved.
